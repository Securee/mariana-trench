/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#include <mariana-trench/FulfilledExploitabilityRuleState.h>

namespace marianatrench {

Taint FulfilledExploitabilityRuleState::fulfill_exploitability_rule(
    const IRInstruction* instruction,
    const SourceSinkWithExploitabilityRule* exploitability_rule,
    const Taint& exploitability_sources,
    const Taint& source_as_transform_sinks) {
  // Update instruction
  instruction_to_rules_[instruction].insert(exploitability_rule);

  LOG(1,
      "Checking rule: {}\nexploitability sources: {}\nsinks: {}",
      exploitability_rule->code(),
      exploitability_sources,
      source_as_transform_sinks);

  if (exploitability_sources.is_bottom()) {
    partially_fulfill_rule(exploitability_rule, source_as_transform_sinks);
    return Taint::bottom();
  }

  std::unordered_set<const Kind*> used_source_kinds;

  auto sources_for_issue = exploitability_sources;
  const auto& rule_exploitability_sources =
      exploitability_rule->effect_source_kinds();
  sources_for_issue.filter_frames(
      [&used_source_kinds, &rule_exploitability_sources](const Frame& frame) {
        const auto* kind = frame.kind();
        if (rule_exploitability_sources.count(kind) > 0) {
          used_source_kinds.insert(kind);
          return true;
        }

        return false;
      });

  // If there are unfulfilled exploitability sources in the rule, the rule is
  // still partially fulfilled and we need to propagate the source-as-transform
  // sink.
  if (std::all_of(
          rule_exploitability_sources.begin(),
          rule_exploitability_sources.end(),
          [&used_source_kinds](const Kind* kind) {
            return used_source_kinds.count(kind) > 0;
          })) {
    fulfill_rule(exploitability_rule, source_as_transform_sinks);
  } else {
    partially_fulfill_rule(exploitability_rule, source_as_transform_sinks);
  }

  return sources_for_issue;
}

void FulfilledExploitabilityRuleState::fulfill_rule(
    const SourceSinkWithExploitabilityRule* rule,
    const Taint& source_as_transform_sinks) {
  // An exploitability rule cannot be partially and fully fulfilled in the same
  // method.
  mt_assert(
      partially_fulfilled_rules_to_source_as_transform_sinks_.count(rule) == 0);

  auto fulfilled_rule_iterator =
      fulfilled_rules_to_source_as_transform_sinks_.find(rule);
  if (fulfilled_rule_iterator ==
      fulfilled_rules_to_source_as_transform_sinks_.end()) {
    LOG(5,
        "Adding fulfilled rule: {} with sink: {}",
        rule->code(),
        source_as_transform_sinks);
    fulfilled_rules_to_source_as_transform_sinks_.emplace(
        rule, source_as_transform_sinks);
  } else {
    LOG(5,
        "Found existing fulfilled rule: {} with sink: {}",
        rule->code(),
        fulfilled_rule_iterator->second);
    fulfilled_rule_iterator->second.join_with(source_as_transform_sinks);
  }
}

void FulfilledExploitabilityRuleState::partially_fulfill_rule(
    const SourceSinkWithExploitabilityRule* rule,
    const Taint& source_as_transform_sinks) {
  // An exploitability rule cannot be partially and fully fulfilled in the same
  // method.
  mt_assert(fulfilled_rules_to_source_as_transform_sinks_.count(rule) == 0);

  auto partial_rule_iterator =
      partially_fulfilled_rules_to_source_as_transform_sinks_.find(rule);
  if (partial_rule_iterator ==
      partially_fulfilled_rules_to_source_as_transform_sinks_.end()) {
    LOG(5,
        "Adding partially fulfilled rule: {} with sink: {}",
        rule->code(),
        source_as_transform_sinks);
    partially_fulfilled_rules_to_source_as_transform_sinks_.emplace(
        rule, source_as_transform_sinks);
  } else {
    LOG(5,
        "Found existing partially fulfilled rule: {} with sink: {}",
        rule->code(),
        partial_rule_iterator->second);
    partial_rule_iterator->second.join_with(source_as_transform_sinks);
  }
}

Taint FulfilledExploitabilityRuleState::partially_fulfilled_sinks(
    const IRInstruction* instruction) const {
  auto iterator = instruction_to_rules_.find(instruction);
  if (iterator == instruction_to_rules_.end()) {
    return Taint::bottom();
  }

  Taint result{};
  for (const auto* rule : iterator->second) {
    auto partial_rule_iterator =
        partially_fulfilled_rules_to_source_as_transform_sinks_.find(rule);
    if (partial_rule_iterator !=
        partially_fulfilled_rules_to_source_as_transform_sinks_.end()) {
      result.join_with(partial_rule_iterator->second);
    }
  }

  return result;
}

Taint FulfilledExploitabilityRuleState::fulfilled_sinks(
    const IRInstruction* instruction) const {
  auto iterator = instruction_to_rules_.find(instruction);
  if (iterator == instruction_to_rules_.end()) {
    return Taint::bottom();
  }

  Taint result{};
  for (const auto* rule : iterator->second) {
    auto fulfilled_rule_iterator =
        fulfilled_rules_to_source_as_transform_sinks_.find(rule);
    if (fulfilled_rule_iterator !=
        fulfilled_rules_to_source_as_transform_sinks_.end()) {
      result.join_with(fulfilled_rule_iterator->second);
    }
  }

  return result;
}

} // namespace marianatrench
